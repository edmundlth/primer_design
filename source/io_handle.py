import logging
import sys
import os
import csv
from Bio import SeqIO
from utils import mean, std_deviation
from primer_search import pick_primer_set, get_primer_seq

def write_aux(aux_writer, searcher):
    """
    This functions takes a Dp_search object write
    the auxiliary information to a file 
    via a specified csv.writer object
    """
    tiles = searcher.aux_data['tiles']
    overlap = searcher.aux_data['overlap']
    num_primers = len(searcher.primer_memo)
    output = [searcher.chrom, searcher.region_start,
              searcher.region_end, searcher.region_length,
              searcher.time_taken, mean(tiles),
              len(tiles), std_deviation(tiles),
              mean(overlap), num_primers]
    aux_writer.writerow(output)


def write_primer(out_writer, searcher, score_correction_exponent):
    '''
    This function take in a Dp_search object, and a csv.writer
    object and write all the primers generated by 
    pick_primer_set() (a generator that yields a pair
    of forward and reverse primers together with their data) 
    to file.
    '''
    region_start = searcher.region_start
    region_length = searcher.region_length
    tile_number = 0
    for f_primer, r_primer in pick_primer_set(searcher, score_correction_exponent):
        tile_number += 1
        f_3_prime, f_length, f_dir = f_primer
        r_3_prime, r_length, r_dir = r_primer
        # using BED file, 0-based open-ended indexing on 
        # the sense strand of DNA
        f_start = f_3_prime - f_length + 1
        f_end = f_3_prime + 1
        r_start = r_3_prime
        r_end = r_3_prime + f_length

        f_seq = get_primer_seq(searcher.reference, f_primer)
        r_seq = get_primer_seq(searcher.reference, r_primer)

        f_score_data = map(str, searcher.primer_memo[f_primer])
        r_score_data = map(str, searcher.primer_memo[r_primer])

        basic_name = searcher.region_name + '_' \
                     + str(region_start) + '_' \
                     + str(region_length) + '_'

        f_name = basic_name + f_dir + str(tile_number)
        r_name = basic_name + r_dir + str(tile_number)

        f_output = [f_name] \
                   + map(str, [f_start, f_end, f_seq, f_length]) \
                   + f_score_data

        r_output = [r_name] \
                   + map(str, [r_start, r_end, r_seq, r_length]) \
                   + r_score_data

        map(out_writer.writerow, [f_output, r_output])
    logging.info("Finish writing primers of %s %s %s to file\n"
                  %(searcher.region_name, 
                    searcher.region_start, 
                    searcher.region_end))

                  
                  
def regions_ref_seqs_generator(user_inputs):
    """
    Using user specified parameters, process
    (filter, merge and warn if user chose to) the input
    BED file, obtain all reference sequence for the processed
    regions, and yield the regions and their reference sequence
    to be tiled and searched.
    """
    final_regions = Handle_Bedfile(bedfile_name = user_inputs.bed,
                                   min_separation = user_inputs.min_sep,
                                   min_region_size = user_inputs.min_size,
                                   want_merge = user_inputs.merge,
                                   want_filter_small = user_inputs.filter_small,
                                   want_filter_closeby = user_inputs.filter_closeby
                                  ).final_regions
    max_tile = user_inputs.tiles[1]
    max_primer_len = user_inputs.primer_length + user_inputs.primer_length_var
    fa_path = user_inputs.fa
    (regions_and_ref_seqs,
     boundary_regions) = get_all_ref_seq(final_regions, max_tile, max_primer_len, fa_path)
    # Regions that are too close to the boundary are filtered out,
    # warned about and ignored.
    # !!! This should be part of the warning stage in Handle_Bedfile()
    # !!! but reading the chromosome sequence is costly, thus we 
    # !!! do it once and do it here only.
    if boundary_regions:
        logging.info("These regions are too close to chromosome's boundary: %s"
                     %str(boundary_regions))
    for region_ref_seq in regions_and_ref_seqs:
        yield region_ref_seq



######## Filter problematic regions in bedfile ##########################

class Handle_Bedfile(object):
    """
    This object handles the input bedfiles.
    User can choose to:
        1) Filter small regions
           - user will specify the minimum size
        2) Merge closeby region
           - user will specify the minimum separation
    This object also serve to filter out regions
    that are too close to the chromosome's 
    boundary, i.e. less than (max_tile -1) + max_primer
    away from boundary.

    All the filtered regions are output to another
    bedfile which will be annotated with its problem
    (too small, too close, or too close to boundary).
    
    Definitions:
    region :: (String, Int, Int)
        - a 3-tuple recording the chromosome (together with name),
          start position and end position of a regions specified
          in the provided BED file.
        - eg: ('chr16_PALB2', 1234, 2345)

    small_regions :: {chromosome:[region]}
        - a dictionary with key=chromosome and value 
          containing regions that are below 
          the specified size
        - eg:
           {'chr1':[('chr1_name11', 123, 234), ('chr1_name12', 236, 245')],
            'chr2':[('chr2_name21', 5678, 6789)]}

    closeby_regions :: {chromosome:[[region]]}
        - a dictionary with key=chromosome and value
          containing a list of list of region.
          the inner most list contain regions that are
          close (within specifed separation) to each other,
          thus the length of the inner most list >=2.
        - eg:
           {'chr1':[
                    [
                     ('chr1_name11', 1234, 2345), 
                     ('chr1_name12', 2346, 2555)
                    ],
                    [
                     ('chr1_name13', 4567, 4678), 
                     ('chr1_name14', 4680, 5600)
                    ]
                   ]
            }
    """
    def __init__(self, bedfile_name, min_separation, min_region_size, 
                 want_merge=True, want_filter_small=True, want_filter_closeby=True):
        problem_bedfilename = '_'.join(os.path.basename(bedfile_name).split('.')[:-1] + ['problems.bed'])
        
        # Initiallise dictionary which will be used to record
        # problematic regions.
        # A region might occur in both dictionary if it is both
        # small and closeby
        small_regions = {}
        closeby_regions = {}

        original_regions = obtain_regions(bedfile_name)

        # if user want to filter out small regions
        # we retain a record of small regions in small_regions
        # and produce another dictionary of regions
        if want_filter_small:
            logging.info("Filtering regions that are smaller than %i"%(min_region_size))
            processed = filter_small_regions(original_regions, min_region_size)
            filtered_regions_small = processed[0]
            small_regions = processed[1]

        # if user want to filter closeby regions
        # or if they specify that they want merging
        # we will produce the filtered and closeby region dictionary
        if want_filter_closeby or want_merge:
            logging.info("Filtering regions that have separation < %i"%min_separation)
            processed = filter_closeby_regions(original_regions, min_separation)
            filtered_regions_closeby = processed[0]
            closeby_regions = processed[1]


        if want_merge:
            # if user also wanted to filter small regions
            # we give warning about regions that are both in the closeby_regions
            # and in the small_regions, and then we proceed to merge them.
            if want_filter_small:
                logging.info('Warning: These are regions that are small but will be merged')
                for chrom, closeby_list in closeby_regions.items():
                    for closeby_group in closeby_list:
                        for region in closeby_group:
                            if chrom in small_regions and region in small_regions[chrom]:
                                logging.info('%s will be merged to %s'
                                             %(str(region), str(closeby_group)))
            merged_regions = merge_closeby_regions(closeby_regions)

        # Now if any filtereing occured
        # we will produce an annotated BEDfile containing all
        # the problematic regions and their data 
        # (size and separation if applicable) and problem annotation.
        if small_regions or closeby_regions:
            problems_output = []
            for chrom, closeby_list in closeby_regions.items():
                for closeby_group in closeby_list:
                    for region in closeby_group:
                        if chrom in small_regions and region in small_regions[chrom]:
                            output = _problem_region_annotate(region, closeby=closeby_group, problem='sc')
                            small_regions[chrom].remove(region)
                        else:
                            output = _problem_region_annotate(region, closeby=closeby_group, problem='c')
                        problems_output.append(output)
            for chrom, small_list in small_regions.items():
                for region in small_list:
                    output = _problem_region_annotate(region, problem='s')
                    problems_output.append(output)
            
            with open(problem_bedfilename, 'w') as problem_bed:
                writer = csv.writer(problem_bed, delimiter='\t')
                map(writer.writerow, problems_output)


        # Now that all potential filtering, merging and problem annotation
        # had accured, we can begin assemble all regions that are suited
        # for tiling.
        self.final_regions = original_regions
        if want_filter_closeby:
            self.final_regions = filtered_regions_closeby
        if want_merge:
            for chrom, merged_list in merged_regions.items():
                if chrom not in self.final_regions:
                    self.final_regions[chrom] = []
                self.final_regions[chrom].extend(merged_list)
        if want_filter_small:
            for chrom, small_list in small_regions.items():
                for region in small_list:
                    if chrom in self.final_regions and region in self.final_regions[chrom]:
                        self.final_regions[chrom].remove(region)




                
def _problem_region_annotate(region, closeby=None, problem='sc'):
    """
    Take in a region and specification of its potential
    problem (small, closeby or both) and generate
    an annotated bedfile row output.
    Annotations:
        sc -> small and close (these regions will be processed)
        c -> close
        s -> small
    eg:
    >>> _problem_region_annotate(('chr1_name', 2330, 2345),
                             closeby=[('chr1_name', 2330, 2345),
                                      ('chr1_other', 2348, 2450)],
                             problem='sc')
    ('chr1', 2330, 2345, 'name', 15, [3], 'sc')
    """
    chr_name, start, end = region
    first_underscore = chr_name.index('_')
    chr = chr_name[:first_underscore]
    name = chr_name[first_underscore+1:]
    if problem == 'sc' or problem == 'c':
        dist = ','.join(map(str, _distances(closeby)))
    else:
        dist = '-'
    length = _region_len(region)
    output = (chr, start, end, name, length, dist, problem)
    return output







def obtain_regions(bedfile):
    """
    bedfile specifies the path to a particular BED file
    The function parse the BED file and return a dictionary
    with chromosome as keys and a list of regions in the particular
    chromosome as values.
    region is of the form:
        (name, start position, end position)
    name :: <chromosome>_<first csv value of 4 column in BED file>
    start and end position are 0-based index of the region.
    eg:
    regions_dict = 
    {'chr1':[('chr1_something', 1234, 1890),('chr1_somethingelse',2345,2890)],
     'chrX':[('chrX_thing', 5678,5999)]}
    """
    with open(bedfile) as file:
        reader = csv.reader(file, delimiter='\t')
        region_dict = {}
        # Obtain a list of regions from bedfile
        for line in reader:
            chrom, start, end, name = line[:4]
            start, end = map(int, [start, end])
            # Use first comma separated value in the 
            # name field and the chromosome as
            # the region name
            bed_specified_name = name.split(',')[0].replace('_','-')
            # The name is potentially empty
            # replace '_' by '-' so that all '_' occurance is 
            # controlled by the program itself instead of the user.
            region_name = chrom + '_' + bed_specified_name
            if chrom in region_dict:
                region_dict[chrom]. append((region_name, start, end))
            else:
                region_dict[chrom] = [(region_name, start, end)]
    return region_dict

def filter_small_regions(region_dict, min_size):
    """
    This function extract all the regions from region_dict
    which are small and return a filtered region_dict and a
    separate small_region dictionary.
    small is defined as smaller than max_tile
    """
    small_regions = {}
    filtered_regions = {}
    for chrom, region_list in region_dict.items():
        for region in region_list:
            if _region_len(region) < min_size:
                if chrom in small_regions:
                    small_regions[chrom].append(region)
                else:
                    small_regions[chrom] = [region]
            else:
                if chrom in filtered_regions:
                    filtered_regions[chrom].append(region)
                else:
                    filtered_regions[chrom] = [region]
    return filtered_regions, small_regions


def filter_closeby_regions(region_dict, min_separation):
    """
    This function extract all the regions that are close to their
    neighbours and return a filtered region dictionary and a 
    closeby regions dictionary.
    Close is defined as less than
        2*(max_tile -1) + 1.5 * max_primer_len
    """
    closeby_regions = {}
    filtered_regions = {}
    for chrom, region_list in region_dict.items():
        region_list.sort(key = lambda x:x[1])
        num_region = len(region_list)

        # identify regions which are too close together
        region_index = 0
        while region_index < num_region:
            num_identified = 1 # A with itself count as 1
            current_region = region_list[region_index]
            while region_index + num_identified < num_region:
                next_region = region_list[region_index+num_identified]
                distance = next_region[1] - current_region[2]

                # Give warning for repeated or overlapping regions
                if distance < 0:
                    logging.info("""WARNING: repeated or overlapping region:
                    %s and %s"""%(str(current_region), str(next_region)))

                if distance < min_separation:
                    num_identified +=1
                else:
                    if num_identified > 1:
                        closeby = region_list[region_index:region_index+num_identified]
                        if chrom in closeby_regions:
                            closeby_regions[chrom].append(closeby)
                        else:
                            closeby_regions[chrom] = [closeby]
                    else:
                        if chrom in filtered_regions:
                            filtered_regions[chrom].append(current_region)
                        else:
                            filtered_regions[chrom] = [current_region]
                    break
            region_index += num_identified
    return filtered_regions, closeby_regions

def merge_closeby_regions(closeby_regions):
    """
    Given a dictionary of closeby regions of the form
        {chromosome:[[region]]} (see doc of Handle_Bedfile())
    produce a another dictionary, merged_regions of the form
       {chromosome:[region]}
    which contain merged regions of the original dictionary.
    """
    merged_regions = {}
    for chrom, closeby_list in closeby_regions.items():
        merged_regions[chrom] = []
        for closeby_group in closeby_list:
            merged_regions[chrom].append(_merge_closeby_group(closeby_group))
            logging.info('\nMerged %i regions: %s\n region length: %s\n distance: %s'
                    %(len(closeby_group),
                      closeby_group,
                      str(map(_region_len,closeby_group)),
                      str(_distances(closeby_group))))
    return merged_regions

def get_all_ref_seq(region_dict, max_tile, max_primer_len, fa_path):
    regions_and_reference = []
    boundary_regions = {}
    for chrom, region_list in region_dict.items():
        if region_list:
            first_region = region_list[0]
            last_region = region_list[-1]
        else:
            logging.info("No region of interest in %s"%chrom)
            continue
        chrom_file_path = os.path.join(fa_path, chrom + '.fa')
        chrom_sequence = SeqIO.read(chrom_file_path, 'fasta').seq
        chrom_len = len(chrom_sequence)
        region_list.sort(key = lambda x:x[1]) # sort using start coord
        # Give warning if region is too close to the chromosome boundary
        # Only check the first and last region in a given chromosome
        # Notice that first and last region might be the same if
        # there is only one region in this particular chromosome.
        min_margin = max_tile + max_primer_len -1
        if first_region[1] < min_margin:
            # move the first element of region_list to boundary_regions
            region_list = region_list[1:]
            boundary_regions[chrom] = [first_region]
            # then give warning
            logging.info("""WARNING: %s is too close to left boundary.\n
                    Require at least %i margin\nbut actual margin is:%i
                    """%(first_region, min_margin, first_region[1]))
        if chrom_len - last_region[2] < min_margin:
            # move last element to boundary_regions
            region_list.pop()
            if boundary_regions[chrom]:
                boundary_regions[chrom].append(last_region)
            else:
                boundary_regions[chrom] = [last_region]
            logging.info("""WARNING: %s is too close to right boundary
                    at %i.\n
                    Require at least %i margin\nbut actual margin is:%i\n
                    """%(last_region,
                        chrom_len-1,
                        min_margin,
                        last_region[1]))
        for current_region in region_list:
            ref_start = current_region[1] - max_tile - max_primer_len +1
            ref_end = current_region[2] + max_tile + max_primer_len
            ref_seq = str(chrom_sequence[ref_start:ref_end])
            regions_and_reference.append((current_region, ref_seq))
        logging.info('Finished acquiring all reference seq of regions in %s'
                     %chrom)
    return regions_and_reference, boundary_regions

                            

def _region_len(region):
    return region[2] - region[1]

def _distances(regions):
    """
    Given a list of region, return a list
    of numbers representing the separation between
    succesive pairs (hence the length of output list
    will be len(regions) -1).
    eg:
    >>> _distance([('chr1_name1', 234, 300),
                   ('chr1_name2', 303, 380),
                   ('chr1_name3', 381, 500)])
    [3, 1]
    """
    distances_list = []
    for index in range(len(regions)-1):
        dist = regions[index+1][1] - regions[index][2]
        distances_list.append(dist)
    return distances_list


def _merge_closeby_group(closeby_list):
    """
    Given a list of closeby regions of the form
        [region]
    produce a single merged region.
    eg:
    >>> _merge_closeby_group([('chr1_name1', 234, 300),
                              ('chr1_name2', 303, 380),
                              ('chr1_name3', 381, 500)])
    ('chr1_name1_name2_name3', 234, 500)
    """
    if len(closeby_list) >= 2:
        first, second = closeby_list[:2]
        merged_first = (_merge_name(first[0], second[0]),
                        first[1],
                        second[2])
        return _merge_closeby_group([merged_first] + closeby_list[2:])
    elif len(closeby_list) == 1:
        return closeby_list[0]
    else:
        logging.info('Error: Trying to merge empty list of regions')
        raise ValueError

def _merge_name(name1, name2):
    """
    Name1 and name2 are of the form
        <chromosome>_<name from bedfile>
    This function will return
        <chromomsome>_<name from bedfile 1>_<name from bedfile 2>
    if the names are the same, only one of the will be used, ie
    we return
        <chromosome>_<name from bedfile>
    """
    name1 = name1.split('_')
    name2 = name2.split('_')
    chrom = name1[0]
    if not (name1[0] == name2[0] == chrom):
        logging.info('WARNING: inconsistent chromosome naming')
    new_name = chrom + '_' + '_'.join(set(name1[1:] + name2[1:]))
    return new_name


#
#def regions_ref_seqs_generator_depreciated(bedfile, user_inputs):
#    """
#    Yields ((chrom_<name>, start pos, end pos), ref sequence)
#    eg : ((chr16_PALB2, 12345, 12357), ATTGCATGGCGT)
#    """
#    want_merging = user_inputs.merge
#    filter_small = user_inputs.filter_small
#    max_tile = user_inputs.tiles[1]
#    max_primer_len = user_inputs.primer_length + user_inputs.primer_length_var
#    fa_path = user_inputs.fa
#    all_regions = obtain_regions(bedfile)
#    # closeby regions filtering:
#    # This is checked and warnings are written to log file.
#    # These regions are merged if user opted to merge them
#    (filtered_regions,
#     closeby_regions) = filter_closeby_regions(all_regions, max_tile, max_primer_len)
#    if want_merging:
#        num_closeby_regions = sum(sum(len(regions) for regions in region_list) 
#                                  for chrom, region_list in closeby_regions.items())
#        # merge and put them back to respective chrom region list
#        merged_regions = merge_closeby_regions(closeby_regions)
#        for chrom, merged in merged_regions.items():
#            filtered_regions[chrom].extend(merged)
#        num_merged_regions = sum(len(regions) for chrom, regions in merged_regions.items())
#        logging.info('Finish merged %i regions into %i regions'
#                     %(num_closeby_regions, num_merged_regions))
#    if filter_small:
#        how_small = int(0.5 * max_tile)
#        (filtered_regions,
#                small_regions) = filter_small_regions(filtered_regions, how_small)
#        logging.info("Regions that are smaller than %i\n"%how_small)
#        for chrom, regions in small_regions.items():
#            logging.info("%s filtered %i regions, lengths: %s"
#                             %(chrom, len(regions), str(map(_region_len,regions))))
#        total_filtered = sum(len(regions) for chrom, regions in small_regions.items())
#        total_left = sum(len(regions) for chrom, regions in filtered_regions.items())
#        total = total_filtered + total_left
#        logging.info('filtered %i out of %i, percentage = %.2f\n\n'
#                         %(total_filtered, total, 100*total_filtered/float(total)))
#
#    (regions_and_ref_seqs,
#     boundary_regions) = get_all_ref_seq(filtered_regions, max_tile, max_primer_len, fa_path)
#    # Regions that are too close to the boundary are filtered out,
#    # warned about and ignored.
#    if boundary_regions:
#        logging.info("These regions are too close to chromosome's boundary: %s"
#                     %str(boundary_regions))
#    for region_ref_seq in regions_and_ref_seqs:
#        yield region_ref_seq
#
#
#def filter_boundary_regions(region_dict, max_tile, max_primer_len):
#    """
#    A function that produces warning about regions that are too
#    close to the background chromosome's boundary. 
#    A regions need to be at least max_tile -1 + max_primer_len
#    away from the boundary at both ends to have enough margin
#    for primer search.
#    These regions are isolated from the region_list of the 
#    chromosome into a another region dictionary
#    """
#    boundary_regions = {}
#    for chrom, region_list in region_dict.items():
#        region_list.sort(key = lambda x:x[1]) # sort using start coord
#        # Give warning if region is too close to the chromosome boundary
#        # Only check the first and last region in a given chromosome
#        first_region = region_list[0]
#        last_region = region_list[-1]
#        # Notice that first and last region might be the same if
#        # there is only one region in this particular chromosome.
#        min_margin = max_tile + max_primer_len -1
#        if first_region[1] < min_margin:
#            # move the first element of region_list to boundary_regions
#            region_list = region_list[1:]
#            boundary_regions[chrom] = [first_region]
#            # then give warning
#            logging.info("""WARNING: %s is too close to left boundary.\n
#                    Require at least %i margin\nbut actual margin is:%i
#                    """%(first_region, min_margin, first_region[1]))
#        if chrom_len - last_region[2] < min_margin:
#            # move last element to boundary_regions
#            region_list.pop()
#            if boundary_regions[chrom]:
#                boundary_regions[chrom].append(last_region)
#            else:
#                boundary_regions[chrom] = [last_region]
#            logging.info("""WARNING: %s is too close to right boundary
#                    at %i.\n
#                    Require at least %i margin\nbut actual margin is:%i\n
#                    """%(last_region,
#                        chrom_len-1,
#                        min_margin,
#                        last_region[1]))
#    return region_dict, boundary_regions
#
#def get_regions_and_ref_seq(region_dict, max_tile, max_primer_len, fa_path):
#    """
#    Let S = starting index of region from the start of 
#    the chromosome and let '-' denote bases outside of region and
#    '*' denote bases in region.
#    We require S >= max_tile + max_primer_len -1
#    The edge case is shown below:
#                               S
#           0 1 2 3 4 5 6 7 8 9 10
#         | - - - - - - - - - - * * * * * * * * * * *
#                     ===========    # max_tile = 6, need 1 base intersect
#           -------->                # max_primer_len = 5
#    Similar condition is imposed for the other end of the chromosome.
#
#    Also, we require that the distant between 2 regions, L to satisfy
#        L >= 2 * (max_tile -1) + max_primer_len +1
#    so that the primers between the regions will never overlap 
#    completely. (DO WE WANT NOT OVERLAP AT ALL??)
#    The edge case is shown below:
#                  <-- 
#            ======    ======        
#                   -->
#        *****--------------******
#    """
#    regions_and_reference = []
#    for chrom, region_list in region_dict.items():
#        chrom_file_path = os.path.join(fa_path, chrom + '.fa')
#        chrom_sequence = SeqIO.read(chrom_file_path, 'fasta').seq
#        chrom_len = len(chrom_sequence)
#        region_list.sort(key = lambda x:x[1])
#        num_region = len(region_list)
#
#        # Merge regions which are too close together
#        region_index = 0
#        while region_index < num_region:
#            num_merged = 1 # Merging A with itself count as 1
#            current_region = region_list[region_index]
#            while region_index + num_merged < num_region:
#                next_region = region_list[region_index+num_merged]
#                distance = next_region[1] - current_region[2]
#                # Give warning for repeated or overlapping regions
#                if distance < 0:
#                    logging.info("""WARNING: repeated or overlapping region:
#                    %s and %s"""%(str(current_region), str(next_region)))
#                min_separation = 2 * (max_tile -1) + 1.5 * max_primer_len 
#                if distance < min_separation:
#                    new_name = _merge_name(current_region[0], next_region[0])
#                    # new name joins the bedspecified name of both regions
#                    # if the names are the same, only one of them is used
#                    new_start = current_region[1]
#                    new_end = next_region[2]
#                    logging.info("MERGED: %s and %s\ndistance: %i"
#                                 %(current_region, next_region, distance))
#                    current_region = (new_name, new_start, new_end)
#                    logging.info("NEW REGION: %s"%str(current_region))
#                    num_merged +=1
#                else:
#                    break
#
#                # obtain reference by slicing chrom sequence
#                # Reference = union of 
#                #       1) Region
#                #       2) Max_tile_size -1 + max_primer_len on both side
#                # reference is obtained here to avoid reading seq again later.
#                #    ----->=====       =====<----- 
#                #              *********
#            ref_start = current_region[1] - max_tile - max_primer_len +1
#            ref_end = current_region[2] + max_tile + max_primer_len
#            ref_seq = str(chrom_sequence[ref_start:ref_end])
#            regions_and_reference.append((current_region, ref_seq))
#            region_index += num_merged
#    return regions_and_reference
#

#def handle_bedfile(bedfile):
#    file = open(bedfile)
#    reader = csv.reader(file,delimiter='\t')
#    bed_row = []
#    for line in reader:
#        chromo, start, end, name = line 
#        start, end = map(int, [start, end])
#        # we dont want underscore character in the bed specified naming
#        # to interfere with our own naming convention
#        bed_specified_name = name.split(',')[0].replace('_','')
#        region_name = chromo + '_' + bed_specified_name 
#        # last term is potentially [''], ie a list of single empty string
#        bed_row.append((region_name, start, end))
#    return bed_row

